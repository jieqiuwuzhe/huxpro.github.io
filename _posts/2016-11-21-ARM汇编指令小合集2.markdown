---
layout:     post
title:      "ARM汇编指令小合集（二）"
subtitle:   " \"ARM汇编程序设计 \""
date:       2016-11-21 17:57:00
author:     "Root"
header-img: "img/post-bg-apple-event-2015.jpg"
catalog: true
tags:
    - 单片机
---

> “在漆黑的夜里你需要一道光照亮夜行的路，所以我燃烧了自己。但也造就了你我永世不能相拥。————复仇焰魂”


### ARM汇编程序设计及格式要求

一般地，ARM源程序文件名的后缀名如下：  
汇编文件：   *.S  
引入文件：   *.INC  
C程序   ：   *.c  
头文件  ：   *.h  

#### 1、汇编语句格式：  

[ 标号 ]  <指令 | 条件 | S >   <操作数>   [ ;注释]

>1、所有标号必须在一行的顶格书写，其后面不要加：  
>2、所有指令均不能顶格书写  
>3、ARM汇编器对标识符大小写敏感，书写标号及指令时字母大小要一致，在ARM汇编程序中，一个ARM指令,伪指令，寄存器名可以全部为大写字母，也可以全部为小写字母，但不要大小写混合使用  
>4、注释使用 ;或者 @，@表示开始到此行结束，注释可以在一行顶格书写（对ADS汇编格式，只支持 ; ）  
>5、源程序中允许空行  
>6、如果单行太长，可以使用字符 / 将其分行， / 后不能有任何字符，包括空格  
>7、对于变量的设置，常量的定义，其标识符必须在一行的顶格书写  

**标号**：在ARM汇编中，标号代表一个地址，根据标号生成方式，可以分为以下3种:  
1、基于PC的标号，例如： BL  LEDTEST  
2、基于寄存器的标号，例如： MAP  0x00,R9  
3、绝对地址，例如： LDR R0,=WTCON  

**局部标号**：主要用于局部范围代码中，对宏定义也非常有用，格式如下：

N { routname }

>N是局部标号，为 0 ~ 99  
>routname是局部标号作用范围的名称  

局部标号引用格式：

 % {F | B }  {A | T}  N {routname }

>其中：
>% 表示局部标号引用操作  
>F 指示编译器只向前搜索  
>B 指示编译器只向后搜索  
>A 指示编译器搜索宏的所有嵌套层次  
>T 指示编译器搜索宏的当前层  

应用举例如下：
       mov   r1, #16
       subs  r1,r1, #1
       bne    %B0

#### 2、宏定义及其作用： 

使用宏定义可以提高程序的可读性，简化程序代码和同步修改，宏首先要定义，然后再使用，当源程序被汇编时，汇编器将展开每一个宏调用，用宏定义体代表程序中的宏调用，并使用实际的参数值代替宏定义时的形式参数。

		.....
		MACRO                             ;宏定义
		CALL  $FUNCTION , $DAT1 , $DAT2   ;宏名称为CALL，带有3个参数
		IMPORT  $FUNCTION                 ; 声明外部子程序
		MOV   R0, $DAT1                   ; 设置子程序参数，R0 = $DAT1
		MOV   R1, $DAT2                   ;
		BL       FUNCTION                 ;  调用子程序
		MEND                              ; 宏定义结束
		......

汇编预处理后，宏调用将被展开，程序清单如下：

		......
		IMPORT  FADD1
		MOV     R0, #3
		MOV     R1, #3
		BL      FADD1

#### 3、子程序的调用：

使用BL指令进行调用，该指令会把返回的PC值保存在LR

示例如下：

		        ......
		        BL  DELAY
		        ......
		DELAY   ....
		         MOV PC,LR

当子程序指令完毕后，使用 MOV, B/BX , STMFD 等指令返回，STMFD 要与 LDMFD配套使用

		STMFD  SP! , {R0-R7, LR}
		......
		LDMFD  SP! , {R0-R7,PC }

ARM7TDMI (-S) 是没有BLX指令的，但可以通过以下几条程序实现其功能

		ADR  R1 ,  DELAY+1 ;
		MOV  LR ,  PC      ;   保存返回地址到LR
		BX      R1         ;   跳转并切换指令集
		......

该程序要注意的是 3级流水线，PC执行到哪里是关键

#### 4、特殊寄存器定义及应用：

基于ARM核的芯片一般有片内外设，它们通过其特殊寄存器访问

示例如下：

		WDTC   EQU  0xE000000    ; 寄存器定义
              ....
                LDR  R0, =WDTC   ; 加载立即数要加 =
                MOV  R1,  #0x12  ;
                STR  R1,  [R0]   ; WDTC = 0x12

#### 5、散转功能：

散转功能是汇编程序常用的一种算法，其示例如下：

       CMP  R0, #MAXINDEX              ; 判断索引号是否超过最大索引值
       ADDLO  PC , PC , R0 , LSL #2    ; 若没有超出，则跳转到相应位置
       B      ERROR                    ; 若已经超出，则进行出错处理
       ; 散转表，对应索引号为 0 ~ N
       B     FUN1
       B     FUN2
       B     FUN3

#### 6、查表功能：

查表操作是汇编程序常用的一种操作，其示例如下：

	         LDR  R3,  =DISP_TAB           ;取得表头
	         LDR  R2 , [R3, R5, LSL #2]   ;根据R5的值查表，取出相应的值
	        ......
	        ;下表为 0 - F 的自模
		DISR_TAB     DCD  0xC0, 0xF9 , 0xA4 , 0x99 , 0x92 , 0xA1, 0xC6,  0x83
		              DCD   0x82. 0xF8 , 0x80 , 0x90 , 0x88 , 0x86, 0x8E , 0xFF

#### 7、长跳转功能：

长跳转功能的实现：ARM的B 和 BL 指令不能全空间跳转，但通过对PC进行复制，实现32位地址的跳转

		ADD  LR , PC , #4   ;保存返回地址，即RET_FUN
		LDR  PC , [PC , # -4] ; 跳转到 LADR_FUN
		DCD  LADR_FUN
		RET_FUN ....

也可以使用伪指令 LDR  PC, =LADR_FUN 实现长跳转

#### 8、一个完整的汇编：

		ABC   EQU  0x12
		     AREA Example , CODE , READONLY   ;声明一个代码段 Example
		     ENTRY                            ; 入口处
		     CODE32
		     ADR R0, THUMB_START + 1          ; 装载地址，并设置第0位为1
		     BX   R0                          ; 切换到THUMB状态
		     CODE 16                          ; 声明 16位代码
		THUMB_START
		     MOV  R1, #ABC
		     ADD  R1, R1 , #0x10
		     B    THUMB_START
		     END

#### 9、外围器件控制：

在ARM核芯片中，其外围部件的控制寄存器，一般会设置“置位/复位”寄存器，这样可以方便的实现位操作，而不影响到其它位，操作示例如下：

		LDR  R0 , =GPIO_BASE
		MOV  R1 , #0x00
		STR  R1 , [R0 , #0x04 ]
		MOV  R1 ,  #0x10
		STR  R1 ,  [R0 , #0x0C]

### C与汇编混合编程

### C与汇编相互调用

#### 1、C调用汇编

#### 2、汇编调用C




—— Root 于 2016.11


