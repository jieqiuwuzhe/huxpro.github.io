---
layout:     post
title:      "面试题目汇总"
subtitle:   " \"面试题目汇总之啥都有啊啥都有 \""
date:       2016-09-30 20:57:00
author:     "Root"
header-img: "img/post-bg-digital-native.jpg"
catalog: true
tags:
    - C语言
---

> “我总是让你那么担心，是不是你永远都会变成它，守护在我身边？————黑暗之女 ”

最近面试挺多的，整理整理一些面试题目吧 O(∩_∩)O 

#### 1、局部变量和全局变量能否重名？

可以。在局部变量作用域内，局部变量可以屏蔽全局变量。同样的，对某些编译器，同一函数内两个不同循环体内部定义同名的局部变量都是允许的。

#### 2、如何引用一个已经定义过的全局变量？

extern / 或者引用头文件的方式。

#### 3、全局变量可否定义在可以被多个C包含的头文件中？why？

可以。但是！必须在不同的C文件中以 static 方式声明同名全局变量，并且只能有一个C文件对此变量赋值，否则连接时会出错。

#### 4、static 全局变量与普通全局变量有什么区别？ static 局部变量与普通局部变量有什么区别？ static 函数与普通函数有什么区别？

全局变量：就存储方式而言，全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式，没有不同。但是在作用域上，非静态全局变量作用域是整个源程序，静态全局变量的作用域只是本文件。

局部变量：改变了存储方式，即改变了生存周期。只有本函数能使用，但是退出函数时，变量值还在，下次进入函数时会保持值不变。

#### 5、变量、常量、程序的存储位置？

局部变量储存在 堆栈 中； 全局变量储存在 静态区 中； 动态申请数据储存在 堆 中。

bss段：用来存放程序中未初始化的全局变量；

data段：用来存放程序中已经初始化的全局变量；

text段：用来存放程序执行代码；

堆heap：用来存放进程运行中被动态分配的内存段，大小不固定，可动态扩张或缩减（malloc 或 free）；

栈stack：用户存放程序临时创建的局部变量。

#### 6、队列和栈区别？

队列FIFO，栈LIFO

#### 7、对于一个频繁使用的短小函数，C 和 C++ 中分别用什么实现？

C用宏定义，C++用 inline

#### 8、进程和线程的区别

线程是进程内的一个执行单元，也是进程内的可调度实体。

区别：

（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

（2）并发性：进程间可以并发，同一进程内的线程也可并发。

（3）拥有资源：进程是拥有资源的一个独立单元，线程不拥有系统资源，但可以访问隶属于进程的资源。

（4）系统开销：创建或撤销进程时，系统都要为其分配和回收资源，导致系统开销明显大于线程的创建和撤销。

#### 9、Heap 和 Stack 的区别

堆和栈的区别：栈的空间是由操作系统自动分配及释放的，堆上的空间手动分配及释放。

栈的空间有限，而堆是很大的自由存储区。

malloc函数分配的内存空间就是在堆上，C++中对应的是 new 操作符。

程序在编译器件对变量和函数分配内存都在栈上进行，程序运行过程中函数调用时参数的传递也在栈上进行。

#### 10、Winbdows下内存是如何管理的？

分页管理。

#### 11、NAND 和 NOR 的区别

NOR 可以芯片内执行，不必再把代码读到 RAM 中，传输效率高，但写入、擦除速率低，1~4M小容量时比较适用。

NAND存储密度大，写入/擦除速率快，容量大且便宜，但是无法片内直接寻址运行程序，只能存储数据且很容易出现坏块，需要校验算法。

NAND的坏块管理BBM（Bad Block Management）:

以K9F2808U0C为例，16M*8bit的NAND Flash，共有1024个block，1个block为16K，1个block有32页，1页=528B（512+16），其中16B位备用区，存放出厂坏块标记、ECC校验码及用户自定义区等。

Flash的最后三个块存放三份BBI（Bad Block Information）表，当Flash首次上电，固件程序 通过读取Flash ID，获得设备的容量等信息，然后从Flash的最后一块中寻找BBI表，如果最后一块没有发现BBI表，则认为此块为坏块，继续前移寻找，依此类推，直到在预留的3个块中找到，并将其数据读入到在主控芯片为其开设的RAM中。如果还找不到，则固件认为该片Flash没有BBI表。

当主机向数据区写数据时，检测到当前块(数据区)为坏块时，将数据写到坏块映射区中的相应好块中，并且将这两个块的块地址记录到BBI表中，以后主机若要对当前块(数据区)访问时，只需读BBI表就可以找到相应映射块，从而代替坏块的访问。这样就使文件系统所见逻辑块地址 LBA（Logical Block Address）变成连续的，但实际上物理块地址PBA（Physical Block Address）可能并不连续。上述方法就是坏块管理的精髓。

#### 12、UBOOT的启动流程

U-Boot启动内核的过程可以分为两个阶段，两个阶段的功能如下：

（1）第一阶段的功能

Ø  硬件设备初始化

Ø  加载U-Boot第二阶段代码到RAM空间

Ø  设置好栈

Ø  跳转到第二阶段代码入口

（2）第二阶段的功能

Ø  初始化本阶段使用的硬件设备

Ø  检测系统内存映射

Ø  将内核从Flash读取到RAM中

Ø  为内核设置启动参数

Ø  调用内核

#### 13、const、static与volatile

static主要用来在调用过程中维持变量值不变以及限定作用范围。

const主要用来修饰只读的值，

		char * const p; //常量指针，p的值不可以修改  
		char const * p；//指向常量的指针，指向的常量值不可以改 
		const char *p； //和char const *p一样
		char const * a const; //不仅p的值不能变，p指向的常量值也不能变

volatile的作用是：确保本条指令不会因编译器的优化而省略，且要求每次直接读值.简单地说就是防止编译器对代码进行优化.一个定义为volatile的变量是说这变量可能会被意想不到地改变，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
		
		eg:
		XBYTE[2]=0x55;
		XBYTE[2]=0x56;
		XBYTE[2]=0x57;
		XBYTE[2]=0x58;

对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有XBYTE[2]=0x58（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，则编译器会逐一的进行编译并产生相应的机器代码（产生四条代码）.

#### 14、ASSERT()是干什么用的

ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0),  程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。

ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。



That's it！！！


—— Root 于 2016.9


