---
layout:     post
title:      "ARM汇编指令小合集"
subtitle:   " \"常用ARM指令及汇编 \""
date:       2016-11-21 07:57:00
author:     "Root"
header-img: "img/post-bg-e2e-ux.jpg"
catalog: true
tags:
    - 单片机
---

> “物是人非，可我依旧穿着嫁衣，在黑夜中寻找你的身影。————寡妇制造者”


**常用ARM指令及汇编包括：**

>ARM处理器寻址方式  
>指令集介绍  
>伪指令  
>ARM汇编程序设计  
>C与汇编混合编程  

### ARM处理器寻址方式

#### 1、寄存器寻址

指令执行时直接取出寄存器的值进行操作：  

		MOV R1, R2      ;	R2    ->R1
		SUB R0, R1,R2   ;   R1-R2 ->R0  

#### 2、立即寻址

数据包含在指令当中：  

		/*SUBS和SUB的区别：SUB不带进位，SUBS带进位*/
		SUBS R0, R0, #1 ;	R0-1   ->R0
		MOV  R0, #0xff00;	0xff00 ->R0

#### 3、寄存器偏移寻址

ARM特有的寻址方式：  

		MOV  R0, R2, LSL #1 ;	 R2的值左移3位，存入R0，R0=R2*8
		ANDS R1, R1, R2, LSL R3; R2的值左移R3位，然后和R1相与，结果放入R1

偏移寻址可采用的移位操作：

> LSL:逻辑左移，低端空位补0  
> LSR:逻辑右移，高端空位补0  
> ASR:算术右移，保持符号位不变（源操作数为正数，最高位为0，右移则补0，反之，反之。）  
> ROR:循环右移，低端移出位填入高端空出位  
> RRX:操作数右移一位，左侧空位由**CPSR（程序状态寄存器）**的C位填充  

#### 4、寄存器间接寻址

类似于C指针，地址操作：  

		LDR  R1, [R2]     ;	 R2中的数作为地址，取出此地址中的数据保存在R1中
		SWP  R1, R1, [R2] ;  R2中的数作为地址，取出此地址中的数据与R1的值交换

#### 5、基址寻址

基地址进行一定运算再进行下一步操作： 

		LDR  R2, [R3,#0x0F] ; R3中的数加0x0f作为地址，取出此地址中的数据保存在R2中
		STR  R1, [R2 #-2]   ; R2中的数减2作为地址，把R1的值保存在此地址位置

#### 6、多寄存器寻址

一次可以传送多个寄存器的值：  

		LDMIA  R1!, {R2-R7，R12} ; 将R1指向的地址的数据读出到R2-R7,R12，R1自动更新
		STMIA  R0!, {R3-R6，R10} ; 将R3-R6,R10中的数值保存到R0指向的地址，R0自动更新

#### 7、堆栈寻址

堆栈寻址使用专门寄存器（堆栈指针SP），指向一块存储区域——堆栈，堆栈可以分为两种：向高地址生长的称为**递增堆栈**，向低地址生长的称为**递减堆栈**。有以下四种情况：

> 1、满递增；堆栈通过增大存储器地址向上增长，SP指向有效数据的最高地址，指令 LDMFA,STMFA   
> 2、空递增：堆栈通过增大存储器地址向上增长，SP指向堆栈上第1个空位置，指令 LDMEA,STMEA   
> 3、满递减：堆栈通过减小存储器地址向下增长，SP指向有效数据的最低地址，指令 LDMFD,STMFD   
> 4、空递减：堆栈通过减小存储器地址向下增长，SP指向堆栈下第1个空位置，指令 LDMED,STMED   

		STMFD  SP!, {R1-R7，LR} ; 将R1-R7,LR向下入栈
		LDMFD  SP!, {R1-R7，LR} ; 数据出栈，放入R1-R7,LR寄存器

#### 8、块拷贝寻址

多寄存器传送指令，将一块数据从存储器的某一位置拷贝到另一位置：  

		STMIA R0!,{R1-R7}  ; 将R1-R7的数据保存到存储器中，存储器指针在保存第一个值之后增加，方向向上增长    
		STMIB R0!,{R1-R7}  ; 将R1-R7的数据保存到存储器中，存储器指针在保存第一个值之前增加，方向向上增长    
		STMDA R0!,{R1-R7}  ; 将R1-R7的数据保存到存储器中，存储器指针在保存第一个值之后增加，方向向下增长    
		STMDB R0!,{R1-R7}  ; 将R1-R7的数据保存到存储器中，存储器指针在保存第一个值之前增加，方向向下增长    

		不管是向上还是向下递增，存储时高编号的寄存器放在高地址的内存，出来时高地址的内容给高编号的寄存器。

#### 9、相对寻址

基寻址的一种变通，由程序计数器PC提供基准地址，地址码字作为偏移量，相加后得到的地址即为操作数的有效地址。

		BL  ROUTE1 ;  调用到 ROUTE1 子程序
		BEQ LOOP   ;  条件跳转到LOOP标号处


### 指令集介绍

#### 1、指令格式

**指令格式**：< opcode > {< cond >}{S}<Rd>,<Rn>,{< operand2 >}  
> 注：<>内是必填项，{}内是选填  

>  opcode ：指令助记符，如 LDR，STR   
>    cond ：执行条件，如 EQ，NE   
>       S ：是否影响CPSR的值，书写时影响CPSR，否则不影响    
>      Rd ：目标寄存器   
>      Rn ：第一个操作数的寄存器   
>operand2 ：第二个操作数

指令举例：

		LDR        R0, [R1] ;  读取R1地址上的存储器单元内容，执行条件AL（无条件）
		BEQ        DATAEVEN ;  跳转指令，执行条件EQ，即相等跳转到 DATAEVEN
		ADDS     R1, R1, #1 ;  加法指令，R1+1 => R1，影响CPSR寄存器（带S）
		SUBNES R1, R1, #0xD ;  条件执行减法运算（NE），R1-0xD => R1，影响CPSR（带S）

#### 2、条件码表

|条件助记符|   标志  |           含义          |
|:--------:|:-------:|:-----------------------:|
|    EQ    |   Z=1   |           相等          |
|    NE    |   Z=0   |          不相等         |
|   CS/HS  |   C=1   |    无符号数大于或等于   |
|   CC/LO  |   C=0   |       无符号数小于      |
|    MI    |   N=1   |           负数          |
|    PL    |   N=0   |           正数          |
|    VS    |   V=1   |           溢出          |
|    VC    |   V=0   |          无溢出         |
|    HI    | C=1,Z=0 |       无符号数大于      |
|    LS    | C=0,Z=1 |    无符号数小于或等于   |
|    GE    |   N=V   |    带符号数大于或等于   |
|    LT    |   N!=V  |       带符号数小于      |
|    GT    | Z=0,N=V |       带符号数大于      |
|    LE    | Z=1,N!=V|    带符号数小于或等于   |
|    AL    |         |任何无条件执行（default）|

条件码应用举例：  

1、比较两个值大小

		if(a>b)	a++;
		else b++;
		    | 
		    V
		//设R0为a，R1为b
		  CMP R0，R1     ; R0与R1比较 
		ADDHI R0，R0，#1 ; R0>R1，则R0=R0+1 
		ADDLS R1，R1，#1 ; R0<R1，则R1=R1+1    

2、若两个条件均成立则将两个数值相加

		if((a!=10)&&(b!=20)) a=a+b;
				|
				V
		  CMP R0，#10    ; 比较R0是否为10 
		CMPNE R1，#20    ; 若R0不为10，则比较R1是否为20 
		ADDNE R0，R0, R1 ; 若R0不为10且R1不为20，则执行R0 = R0+R1 

3、若两个条件有一个成立，则将两个数值相加

		if((a!=10)||(b!=20)) a=a+b;
				|
				V
		  CMP R0，#10    ; 比较R0是否为10 
		CMPEQ R1，#20    ; 若R0等于10，则比较R1是否为20 
		ADDNE R0，R0, R1 ; 若R0不为10或R1不为20，则执行R0 = R0+R1 


#### 3、ARM存储访问指令

**LDR、STR、LDM、STM、SWP**

(1) LDR\STR：加载\存储字和无符号字节指令  
有以下4种形式：  
1、零偏移：      LDR Rd, [Rn]  
2、前索引偏移：  LDR Rd, [Rn, #0x04]!, Rn不允许为R15    
3、程序相对偏移：LDR Rd, label  
4、后索引偏移：  LDR Rd, [Rn], #0x04, Rn不允许为R15  

指令举例：  

		LDR  R2,  [R5]        ;  加载R5指定地址的数据放入R2
		STR  R1,  [R0，#0x04] ;  将R1的数据存储到 R0+0x04 存储单元，R0保持不变（若有！，则R0需要更新）
		LDRB R3,  [R2], #1    ;  读取R2地址上1字节数据保存到R3，R2=R2+1
		STRH R1,  [R0, #2]!   ;  将R1数据保存到 R0+2 地址，只存储低2字节数据，R0=R0+2

(2) LDM\STM：批量加载\存储指令，LDM加载多个寄存器，STM存储多个寄存器，主用于现场保护、数据复制、参数传递等。  
有8种模式，前四种用于数据块传输，后4种用于堆栈操作。  
IA：每次传送后地址加4  
IB：每次传送前地址加4  
DA：每次传送后地址减4  
DB：每次传送前地址减4  
FD：满递减堆栈  
ED：空递减堆栈  
FA：满递增堆栈  
EA：空递增堆栈  

指令举例：  

		// 批量加载/存储
		LDMIA R0!, {R3-R9}     ;  加载R0指向的地址上的多字数据，保存到R3-R9中，R0更新
		STMIA R1!, {R3-R9}     ;  将R3-R9数据保存到R1指向的地址上，R1更新
		STMFD SP!, {R0-R7，LR} ;  现场保存，将R0-R7、LR入栈
		LDMFD SP!, {r0-r7, PC} ;  恢复现场，异常返回处理

		//使用LDM/STM进行数据复制
		LDR R0, = SrcData    ;  设置源数据地址，LDR此时作为伪指令加载地址，要加 = 
		LDR R1, = DstData    ;  设置目标地址
		LDMIA R0, {R2-R9}    ;  加载8字节数据到寄存器R2-R9
		LDMIA R1, {R2-R9}    ;  存储寄存器R2-R9到目标地址上

		//使用LDM/STM进行现场保护，常用在子程序或异常处理中
		STMFD SP!,{R0-R7,LR} ;  寄存器入栈
			.....
		BL DELAY             ;  调用DELAY子程序
			.....
		LDMFD SP!,{R0-R7,PC} ;  恢复寄存器，并返回






—— Root 于 2016.11


